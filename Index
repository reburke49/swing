<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Bat Swing Calculator (Alignment-Free)</title>
<style>
  :root { --bg:#0b1020; --card:#121933; --ink:#e9eefc; --muted:#97a0c0; --accent:#7aa2ff; }
  *{box-sizing:border-box}
  body{margin:0;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:linear-gradient(180deg,#0b1020 0%,#0e1530 100%);color:var(--ink)}
  header{padding:24px;text-align:center}
  header h1{margin:0 0 6px;font-size:1.6rem}
  header p{margin:0;color:var(--muted)}
  .wrap{max-width:1200px;margin:0 auto;padding:20px;display:grid;gap:16px}
  .grid{display:grid;grid-template-columns:1.2fr 1fr;gap:16px}
  @media (max-width:1100px){.grid{grid-template-columns:1fr}}
  .card{background:var(--card);border:1px solid #22305f;border-radius:12px;padding:16px}
  h2{margin:0 0 12px;font-size:1.1rem}
  textarea{width:100%;min-height:220px;background:#0c1433;color:var(--ink);border:1px solid #22305f;border-radius:10px;padding:12px;resize:vertical}
  .controls{display:flex;flex-wrap:wrap;gap:10px;align-items:center;margin:10px 0 0}
  .btn{background:var(--accent);color:#0b1020;border:0;padding:10px 14px;border-radius:10px;font-weight:600;cursor:pointer}
  .btn.secondary{background:#273a7a;color:#d8e2ff}
  .muted{color:var(--muted);font-size:.95rem}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  .stat{padding:10px 12px;background:#0c1433;border:1px solid #22305f;border-radius:10px}
  label{color:var(--muted);font-size:.92rem}
  input[type="file"]{display:none}
  .drop{border:1px dashed #3550a8;padding:10px;border-radius:10px;text-align:center;color:var(--muted)}
  canvas{width:100%;height:280px;background:#0a1128;border:1px solid #22305f;border-radius:10px}
  table{width:100%;border-collapse:collapse}
  th,td{padding:8px 10px;border-bottom:1px solid #22305f;text-align:left}
  th{color:#afbbdf;font-weight:600}
  select,input[type="number"],input[type="text"]{background:#0c1433;color:var(--ink);border:1px solid #22305f;border-radius:8px;padding:8px}
  .footer{text-align:center;color:var(--muted);padding:18px;font-size:.9rem}
</style>
</head>
<body>
<header>
  <h1>Bat Swing Calculator (Alignment-Free)</h1>
  <p>Paste WT901 export (TSV/CSV) or drop a file. Swings auto-detected & labeled.</p>
</header>

<div class="wrap">
  <div class="card">
    <h2>Paste data or drop a file</h2>
    <div class="drop" id="dropZone">Drop .csv or .tsv here, or paste into the box</div>
    <textarea id="raw" placeholder="Headers like: time, AccX(g), AccY(g), AccZ(g), AsX(°/s), AsY(°/s), AsZ(°/s)..."></textarea>
    <div class="controls">
      <label class="row"><span>Radii (m):</span><input id="radii" type="text" value="0.50 0.58 0.66"></label>
      <label class="row"><span>Smooth N (gyro):</span><input id="smoothN" type="number" min="1" max="21" step="1" value="3"></label>
      <label class="row"><span>Robust peak %:</span><input id="pct" type="number" min="90" max="100" step="0.5" value="98"></label>

      <!-- Auto/manual threshold -->
      <label class="row">
        <span>Detection:</span>
        <select id="mode"><option value="auto" selected>Auto (recommended)</option><option value="manual">Manual</option></select>
      </label>
      <label class="row" id="manualBox" style="display:none">
        <span>ω thresh (rad/s):</span><input id="wThresh" type="number" min="0" step="0.5" value="10">
      </label>

      <button class="btn" id="analyze">Analyze</button>
      <label for="file" class="btn secondary">Choose file</label><input id="file" type="file" accept=".csv,.tsv,.txt">
      <button class="btn secondary" id="download">Download JSON</button>
    </div>
    <p class="muted">Auto mode learns a baseline from your data (median + MAD) with hysteresis; no tuning needed. Manual mode lets you set a fixed ω threshold.</p>
  </div>

  <div class="grid">
    <div class="card">
      <h2>Results (overall)</h2>
      <div class="row" id="stats"></div>
      <p class="muted" id="meta"></p>
    </div>
    <div class="card">
      <h2>Swings detected</h2>
      <div class="row" style="margin-bottom:10px">
        <label class="row"><span>Show swing:</span>
          <select id="swingSelect"><option value="-1" selected>All swings (overlay)</option></select>
        </label>
        <label class="row"><span>Speed plot radius (m):</span><input id="plotR" type="number" step="0.01" value="0.58"></label>
        <button class="btn secondary" id="plotSwing">Replot</button>
      </div>
      <div id="swingsTableWrap"></div>
    </div>
  </div>

  <div class="grid">
    <div class="card">
      <h2>Dynamic acceleration magnitude (|a| − 1 g)</h2>
      <canvas id="dynChart" width="800" height="280"></canvas>
    </div>
    <div class="card">
      <h2>Instantaneous barrel speed</h2>
      <canvas id="speedChart" width="800" height="280"></canvas>
    </div>
  </div>

  <div class="card">
    <h2>Notes</h2>
    <ul class="muted">
      <li>Speeds use |ω| × R (orientation-invariant). Robust peak uses a percentile to avoid spikes.</li>
      <li>Auto segmentation: baseline = median(|ω|), scale = 1.4826·MAD(|ω|). High/low thresholds add hysteresis.</li>
      <li>Min swing duration and gap are derived from sampling rate (adaptive), so it works at different IMU rates.</li>
    </ul>
  </div>
</div>

<div class="footer">© You. Static HTML. No data leaves your browser.</div>

<script>
/* ---------- helpers ---------- */
const byId = (id)=>document.getElementById(id);
const fmt = (x,d=2)=> (isFinite(x) ? Number(x).toFixed(d) : "—");
const mph = mps => mps*2.23693629;

function detectSep(text){
  const tabs=(text.match(/\t/g)||[]).length, commas=(text.match(/,/g)||[]).length;
  return tabs>=commas ? "\t" : ",";
}
function parseTable(text){
  const sep = detectSep(text);
  const lines = text.trim().split(/\r?\n/).filter(s=>s.trim().length>0);
  if(!lines.length) throw new Error("No rows.");
  const header = lines[0].split(sep).map(s=>s.trim());
  const rows = lines.slice(1).map(line=>line.split(sep));
  const map={}; header.forEach((h,i)=>map[h.toLowerCase()]=i);

  function findCol(opts){
    for(const o of opts){ if(map.hasOwnProperty(o.toLowerCase())) return map[o.toLowerCase()]; }
    for(const k in map){ for(const o of opts){ if(k.replace(/\s+/g,'').includes(o.toLowerCase().replace(/\s+/g,''))) return map[k]; } }
    throw new Error("Missing column: "+opts.join(", "));
  }
  const idx = {
    time: findCol(["time","timestamp"]),
    ax: findCol(["AccX(g)","accx","ax","acc_x"]),
    ay: findCol(["AccY(g)","accy","ay","acc_y"]),
    az: findCol(["AccZ(g)","accz","az","acc_z"]),
    gx: findCol(["AsX(°/s)","GyroX(°/s)","gx","gyro_x"]),
    gy: findCol(["AsY(°/s)","GyroY(°/s)","gy","gyro_y"]),
    gz: findCol(["AsZ(°/s)","GyroZ(°/s)","gz","gyro_z"])
  };
  const out={time:[],ax:[],ay:[],az:[],gx:[],gy:[],gz:[]};
  for(const r of rows){
    const t=r[idx.time], ax=parseFloat(r[idx.ax]), ay=parseFloat(r[idx.ay]), az=parseFloat(r[idx.az]),
          gx=parseFloat(r[idx.gx]), gy=parseFloat(r[idx.gy]), gz=parseFloat(r[idx.gz]);
    if([ax,ay,az,gx,gy,gz].some(v=>!isFinite(v))) continue;
    out.time.push(new Date(t)); out.ax.push(ax); out.ay.push(ay); out.az.push(az); out.gx.push(gx); out.gy.push(gy); out.gz.push(gz);
  }
  if(out.time.length<3) throw new Error("Not enough numeric rows.");
  return out;
}
function movingAverage(a,n=3){
  if(n<=1) return a.slice();
  const o=new Array(a.length).fill(0), w=new Array(n).fill(1/n);
  for(let i=0;i<a.length;i++){ let s=0,c=0;
    for(let k=0;k<n;k++){ const j=i+k-Math.floor(n/2); if(j>=0&&j<a.length){ s+=a[j]*w[k]; c+=w[k]; } }
    o[i]=s/(c||1);
  } return o;
}
function percentile(arr,p){
  const v=arr.slice().sort((a,b)=>a-b); if(!v.length) return NaN;
  const r=(p/100)*(v.length-1), i=Math.floor(r), f=r-i;
  return (i+1<v.length)? v[i]*(1-f)+v[i+1]*f : v[i];
}
function median(arr){ const v=arr.slice().sort((a,b)=>a-b); const n=v.length; return n%2? v[(n-1)/2] : (v[n/2-1]+v[n/2])/2; }
function mad(arr){ const m=median(arr); return median(arr.map(x=>Math.abs(x-m))); }
function diffSeconds(ts){
  const d=[]; for(let i=1;i<ts.length;i++) d.push((ts[i]-ts[i-1])/1000);
  d.sort((a,b)=>a-b); return d.length? d[Math.floor(d.length/2)] : 0.01;
}

/* ---------- core metrics ---------- */
function computeMetrics(data, opts){
  const {smoothN=3, robustPct=98, radii=[0.50,0.58,0.66]} = opts;
  const accMag = data.ax.map((_,i)=>Math.hypot(data.ax[i],data.ay[i],data.az[i]));
  const dynG = accMag.map(x=>Math.max(0,x-1.0));
  const idxMaxG = dynG.reduce((m,v,i)=>v>dynG[m]?i:m,0);

  const omegaDeg = data.gx.map((_,i)=>Math.hypot(data.gx[i],data.gy[i],data.gz[i]));
  const omega = movingAverage(omegaDeg,smoothN).map(x=>x*Math.PI/180);
  const omegaAbsMax = Math.max(...omega);
  const omegaRobust = percentile(omega, robustPct);
  const dt = diffSeconds(data.time.map(t=>t.getTime()));

  return {
    time:data.time, dt, accMag, dynG, idxMaxG, tMaxG:data.time[idxMaxG],
    omega, omegaAbsMax, omegaRobust,
    speeds: radii.map(R=>({R,
      v_absmax_mps:omegaAbsMax*R, v_absmax_mph:mph(omegaAbsMax*R),
      v_robust_mps:omegaRobust*R, v_robust_mph:mph(omegaRobust*R)}))
  };
}

/* ---------- AUTO swing segmentation (median + MAD + hysteresis) ---------- */
function segmentSwingsAuto(time, omega){
  const wAbs = omega.map(Math.abs);
  const m = median(wAbs), s = 1.4826*mad(wAbs) || (percentile(wAbs,75)-percentile(wAbs,25))/1.349 || 1;
  // High/low thresholds (hysteresis). k tuned for practice swings.
  const high = m + 3.0*s;
  const low  = m + 1.8*s;

  // Adaptive durations from sampling rate
  const dt = diffSeconds(time.map(t=>t.getTime()));
  const minDur = Math.max(0.14, 6*dt);   // ≥ ~140ms
  const gapDur = Math.max(0.25, 10*dt);  // ≥ ~250ms

  // Convert to samples
  const minLen = Math.max(3, Math.round(minDur/dt));
  const gapLen = Math.max(3, Math.round(gapDur/dt));

  const n=wAbs.length, segs=[];
  let inSwing=false, start=0, below=0;

  for(let i=0;i<n;i++){
    if(!inSwing){
      if(wAbs[i]>=high){ inSwing=true; start=i; below=0; }
    }else{
      if(wAbs[i]<=low){ below++; if(below>=gapLen){ const end=Math.max(start, i-below+1); if(end-start+1>=minLen) segs.push([start,end]); inSwing=false; below=0; } }
      else below=0;
    }
  }
  if(inSwing){ const end=n-1; if(end-start+1>=minLen) segs.push([start,end]); }

  // require each swing to have a meaningful robust peak (> m + 2*s)
  const strong = segs.filter(([a,b])=> percentile(wAbs.slice(a,b+1),98) >= (m + 2.0*s));
  // merge tiny gaps
  const merged=[]; for(const seg of strong){ if(!merged.length){ merged.push(seg); continue; }
    const last=merged[merged.length-1]; const gapSamp=seg[0]-last[1]-1;
    if(gapSamp<=Math.round(0.12/dt)) last[1]=seg[1]; else merged.push(seg);
  }
  return {segments:merged, thresholds:{median:m, mad:s/1.4826, sigma:s, high, low, dt, minDur, gapDur}};
}

/* ---------- MANUAL segmentation (fixed threshold) ---------- */
function segmentSwingsManual(time, omega, wThresh){
  const w = omega.map(Math.abs);
  const dt = diffSeconds(time.map(t=>t.getTime()));
  const minLen = Math.max(3, Math.round(Math.max(0.14, 6*dt)/dt));
  const gapLen = Math.max(3, Math.round(Math.max(0.25,10*dt)/dt));
  const segs=[]; let cur=[];
  for(let i=0;i<w.length;i++){
    if(w[i]>wThresh){ cur.push(i); }
    else if(cur.length){ if(cur.length>=minLen) segs.push([cur[0],cur[cur.length-1]]); cur=[]; }
  }
  if(cur.length>=minLen) segs.push([cur[0],cur[cur.length-1]]);
  // merge gapLen
  const merged=[]; for(const s of segs){ if(!merged.length){ merged.push(s); continue; }
    const last=merged[merged.length-1]; if(s[0]-last[1]-1<=gapLen) last[1]=s[1]; else merged.push(s);
  }
  return {segments:merged, thresholds:{manual:wThresh, dt}};
}

/* ---------- plotting ---------- */
function lineChart(canvas, t, y, label="", segments=null){
  const ctx=canvas.getContext("2d"), W=canvas.width, H=canvas.height;
  ctx.clearRect(0,0,W,H); if(!y.length) return;
  const t0=t[0].getTime(), xs=y.map((_,i)=>(t[i].getTime()-t0)/1000);
  const minY=Math.min(...y), maxY=Math.max(...y), pad=(maxY-minY)*0.1||1, yMin=minY-pad, yMax=maxY+pad;
  ctx.strokeStyle="#27408f"; ctx.lineWidth=1; ctx.beginPath(); ctx.moveTo(50,10); ctx.lineTo(50,H-30); ctx.lineTo(W-10,H-30); ctx.stroke();
  ctx.fillStyle="#98a7d8"; ctx.font="12px system-ui,sans-serif"; ctx.fillText(label,10,14);

  const X=x=>50+(W-60)*(x/(xs[xs.length-1]||1)), Y=v=>(H-30)-(H-40)*((v-yMin)/(yMax-yMin||1));
  if(Array.isArray(segments)&&segments.length){
    ctx.fillStyle="rgba(122,162,255,0.12)";
    for(const [s,e] of segments){ ctx.fillRect(X(xs[s]),10,(X(xs[e])-X(xs[s])),H-40); }
  }
  ctx.strokeStyle="#7aa2ff"; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(X(xs[0]),Y(y[0])); for(let i=1;i<y.length;i++) ctx.lineTo(X(xs[i]),Y(y[i])); ctx.stroke();
  ctx.fillStyle="#6e7fb7"; const xt=6; for(let i=0;i<=xt;i++){ const x=(xs[xs.length-1]||1)*i/xt, px=X(x); ctx.beginPath(); ctx.moveTo(px,H-30); ctx.lineTo(px,H-34); ctx.strokeStyle="#27408f"; ctx.stroke(); ctx.fillText((x).toFixed(2)+"s",px-14,H-10); }
}

/* ---------- UI state ---------- */
let lastData=null, overall=null, segInfo=null, perSwing=[];

function showStats(m, seg){
  const el=byId("stats"); el.innerHTML="";
  const add=(k,v)=>{ const d=document.createElement("div"); d.className="stat"; d.innerHTML=`<div class="muted">${k}</div><div style="font-weight:700">${v}</div>`; el.appendChild(d); };
  const maxDyn=Math.max(...m.dynG);
  add("Max dynamic g (|a|-1)", fmt(maxDyn,2));
  add("Peak ω (abs, rad/s)", fmt(m.omegaAbsMax,2));
  add("Peak ω (robust, rad/s)", fmt(m.omegaRobust,2));
  m.speeds.forEach(s=> add(`Speed @ R=${s.R} m (robust)`, `${fmt(s.v_robust_mps,2)} m/s | ${fmt(s.v_robust_mph,1)} mph`));
  const meta=byId("meta");
  if(seg?.thresholds?.sigma){
    const th=seg.thresholds;
    meta.textContent = `Samples: ${m.time.length}. dt≈${fmt(m.dt*1000,1)} ms. Auto thresholds: median=${fmt(th.median,1)}, sigma=${fmt(th.sigma,1)}, high=${fmt(th.high,1)}, low=${fmt(th.low,1)}. Swings: ${seg.segments.length}.`;
  }else{
    meta.textContent = `Samples: ${m.time.length}. dt≈${fmt(m.dt*1000,1)} ms. Swings: ${seg.segments.length}.`;
  }
}
function buildSwingsTable(){
  const wrap=byId("swingsTableWrap");
  if(!perSwing.length){ wrap.innerHTML='<p class="muted">No swings detected.</p>'; return; }
  let html=`<table><thead><tr>
    <th>Swing</th><th>Start</th><th>End</th><th>Dur (s)</th>
    <th>Peak ω (robust, rad/s)</th><th>Speed @ 0.58 m (mph)</th><th>Max dyn g</th>
  </tr></thead><tbody>`;
  perSwing.forEach((s,i)=>{
    const sp = s.speeds.find(x=>Math.abs(x.R-0.58)<1e-6) || s.speeds[0];
    html+=`<tr><td>Swing ${i+1}</td>
      <td>${new Date(s.startMs).toLocaleTimeString()}</td>
      <td>${new Date(s.endMs).toLocaleTimeString()}</td>
      <td>${fmt(s.duration,2)}</td>
      <td>${fmt(s.omegaRobust,2)}</td>
      <td>${fmt(sp.v_robust_mph,1)}</td>
      <td>${fmt(s.maxDynG,2)}</td></tr>`;
  });
  html+='</tbody></table>'; wrap.innerHTML=html;

  const sel=byId("swingSelect");
  sel.innerHTML='<option value="-1" selected>All swings (overlay)</option>';
  perSwing.forEach((_,i)=>{ const o=document.createElement("option"); o.value=String(i); o.textContent=`Swing ${i+1}`; sel.appendChild(o); });
}

/* ---------- orchestrate ---------- */
function analyzeText(text){
  const data=parseTable(text); lastData=data;
  const smoothN=Math.max(1, parseInt(byId("smoothN").value||"3",10));
  const robustPct=Math.min(100, Math.max(90, parseFloat(byId("pct").value||"98")));
  const radii=(byId("radii").value||"0.58 0.66").split(/\s+/).map(Number).filter(x=>isFinite(x)&&x>0);

  overall=computeMetrics(data,{smoothN, robustPct, radii});

  // segmentation
  const mode=byId("mode").value;
  segInfo = (mode==="manual")
    ? segmentSwingsManual(data.time, overall.omega, parseFloat(byId("wThresh").value||"10"))
    : segmentSwingsAuto(data.time, overall.omega);

  // per-swing metrics
  perSwing = segInfo.segments.map(([s,e],i)=>{
    const sub={ time:data.time.slice(s,e+1), ax:data.ax.slice(s,e+1), ay:data.ay.slice(s,e+1), az:data.az.slice(s,e+1),
                gx:data.gx.slice(s,e+1), gy:data.gy.slice(s,e+1), gz:data.gz.slice(s,e+1) };
    const m=computeMetrics(sub,{smoothN, robustPct, radii});
    return {
      index:i, startMs:sub.time[0].getTime(), endMs:sub.time[sub.time.length-1].getTime(),
      duration:(sub.time.at(-1).getTime()-sub.time[0].getTime())/1000,
      omegaRobust:m.omegaRobust, speeds:m.speeds, maxDynG:Math.max(...m.dynG),
      dynG:m.dynG, omega:m.omega, time:m.time
    };
  });

  // plots
  lineChart(byId("dynChart"), overall.time, overall.dynG, "dynamic g", segInfo.segments);
  const Rplot=parseFloat(byId("plotR").value||"0.58");
  lineChart(byId("speedChart"), overall.time, overall.omega.map(w=>w*Rplot), "m/s", segInfo.segments);

  showStats(overall, segInfo);
  buildSwingsTable();
}

function replotSelected(){
  if(!overall) { alert("Analyze first."); return; }
  const choice=parseInt(byId("swingSelect").value,10);
  const Rplot=parseFloat(byId("plotR").value||"0.58");
  if(choice<0 || !perSwing.length){
    lineChart(byId("dynChart"), overall.time, overall.dynG, "dynamic g", segInfo.segments);
    lineChart(byId("speedChart"), overall.time, overall.omega.map(w=>w*Rplot), "m/s", segInfo.segments);
    return;
  }
  const s=perSwing[choice];
  lineChart(byId("dynChart"), s.time, s.dynG, "dynamic g");
  lineChart(byId("speedChart"), s.time, s.omega.map(w=>w*Rplot), "m/s");
}

/* ---------- events ---------- */
byId("analyze").addEventListener("click", ()=>{
  const text=byId("raw").value;
  if(!text.trim()){ alert("Paste your data first."); return; }
  try{ analyzeText(text); }catch(e){ alert("Parse error: "+e.message); }
});
byId("plotSwing").addEventListener("click", replotSelected);
byId("mode").addEventListener("change", ()=>{ byId("manualBox").style.display = byId("mode").value==="manual" ? "" : "none"; });

/* drag & drop */
const drop=byId("dropZone");
drop.addEventListener("dragover", e=>{ e.preventDefault(); drop.style.background="#0d1742"; });
drop.addEventListener("dragleave", ()=> drop.style.background="");
drop.addEventListener("drop", e=>{
  e.preventDefault(); drop.style.background="";
  const f=e.dataTransfer.files?.[0]; if(!f) return;
  const r=new FileReader(); r.onload=ev=>byId("raw").value=ev.target.result; r.readAsText(f);
});
byId("file").addEventListener("change", e=>{
  const f=e.target.files?.[0]; if(!f) return;
  const r=new FileReader(); r.onload=ev=>byId("raw").value=ev.target.result; r.readAsText(f);
});

/* export */
byId("download").addEventListener("click", ()=>{
  if(!overall){ alert("Analyze first."); return; }
  const report = {
    overall: {
      max_dynamic_g: Number(Math.max(...overall.dynG).toFixed(2)),
      peak_omega_abs_rad_s: Number(overall.omegaAbsMax.toFixed(2)),
      peak_omega_robust_rad_s: Number(overall.omegaRobust.toFixed(2)),
      speeds: overall.speeds.map(s=>({R_m:s.R, v_robust_mps:+s.v_robust_mps.toFixed(3), v_robust_mph:+s.v_robust_mph.toFixed(2)}))
    },
    segmentation: segInfo,
    swings: perSwing.map((s,i)=>({
      label:`Swing ${i+1}`, start_iso:new Date(s.startMs).toISOString(), end_iso:new Date(s.endMs).toISOString(),
      duration_s:+s.duration.toFixed(3), peak_omega_robust_rad_s:+s.omegaRobust.toFixed(2),
      max_dynamic_g:+s.maxDynG.toFixed(2),
      speeds:s.speeds.map(x=>({R_m:x.R, v_robust_mps:+x.v_robust_mps.toFixed(3), v_robust_mph:+x.v_robust_mph.toFixed(2)}))
    }))
  };
  const blob=new Blob([JSON.stringify(report,null,2)],{type:"application/json"});
  const a=document.createElement("a"); a.href=URL.createObjectURL(blob); a.download="swing_report.json"; a.click();
});
</script>
</body>
</html>
